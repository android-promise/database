/*
 * Copyright 2017, Peter Vincent
 * Licensed under the Apache License, Version 2.0, Android Promise.
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package promise.db.ompiler

import com.google.auto.service.AutoService
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asTypeName
import com.squareup.kotlinpoet.jvm.jvmStatic
import net.ltgt.gradle.incap.IncrementalAnnotationProcessor
import net.ltgt.gradle.incap.IncrementalAnnotationProcessorType
import promise.db.DatabaseEntity
import promise.db.Entity
import promise.db.ompiler.annotation.TableAnnotationGenerator
import promise.db.ompiler.migration.MigrationGenerator
import java.io.File
import java.util.*
import javax.annotation.processing.AbstractProcessor
import javax.annotation.processing.Processor
import javax.annotation.processing.RoundEnvironment
import javax.annotation.processing.SupportedOptions
import javax.annotation.processing.SupportedSourceVersion
import javax.lang.model.SourceVersion
import javax.lang.model.element.Element
import javax.lang.model.element.ElementKind
import javax.lang.model.element.TypeElement
import javax.tools.Diagnostic
import kotlin.collections.HashMap

@AutoService(Processor::class) // For registering the service
@IncrementalAnnotationProcessor(IncrementalAnnotationProcessorType.DYNAMIC)
@SupportedSourceVersion(SourceVersion.RELEASE_8) // to support Java 8
@SupportedOptions(EntityProcessor.KAPT_KOTLIN_GENERATED_OPTION_NAME)
class EntityProcessor : AbstractProcessor() {

  override fun process(mutableSet: MutableSet<out TypeElement>?, environment: RoundEnvironment?): Boolean {
    try {
      environment?.getElementsAnnotatedWith(Entity::class.java)
          ?.forEach {
            if (it.kind != ElementKind.CLASS) {
              processingEnv.messager.printMessage(Diagnostic.Kind.ERROR, "Only classes can be annotated")
              return false
            }
            processAnnotation(it)
          }
      return DatabaseProcessor(processingEnv).process(mutableSet, environment)
    } catch (e: Throwable) {
      //processingEnv.messager.printMessage(Diagnostic.Kind.ERROR, "EntityProcessor: ${Utils.getStackTraceString(e)}")
      processingEnv.messager.printMessage(Diagnostic.Kind.ERROR, "EntityProcessor Trace: ${Arrays.toString(e.stackTrace)}")
      return false
    }
  }

  private fun processAnnotation(element: Element) {
    processingEnv.messager.printMessage(Diagnostic.Kind.NOTE, "Entity Processing: ${element.simpleName}")

    val className = element.simpleName.toString()
    val pack = processingEnv.elementUtils.getPackageOf(element).toString()

    val fileName = element.getClassName()
    val fileBuilder = FileSpec.builder(pack, fileName)

    fileBuilder.addComment("Generated by Promise database compiler")

    val tableAnnotationSpec = TableAnnotationGenerator(fileBuilder, element).generate()

    fileBuilder.addImport(pack, className)

    val classBuilder = TypeSpec.classBuilder(fileName)
    classBuilder.addAnnotation(tableAnnotationSpec)
        .primaryConstructor(FunSpec.constructorBuilder()
            .addParameter("database",
                ClassName("promise.db", "FastDatabase"))
            .build())
        .addSuperclassConstructorParameter("database")
        .superclass(ClassName("promise.db", "FastTable")
            .parameterizedBy(ClassName(pack, className)))


    // static column block generation
    val tableColumnPropsGenerator = TableColumnPropsGenerator(fileBuilder, processingEnv, element.enclosedElements)
    val companionBuilder = TypeSpec.companionObjectBuilder()

    val idColumnSpec = PropertySpec.builder("idColumn", ClassName("promise.db", "Column")
        .parameterizedBy(Int::class.asTypeName()))
        .jvmStatic()
        .initializer(CodeBlock.of("""
                id
              """.trimIndent())
        )
        .build()

    companionBuilder.addProperty(idColumnSpec)

    val columnSpecs = tableColumnPropsGenerator.generate()

    columnSpecs.values.forEach {
      companionBuilder.addProperty(it)
    }

    classBuilder.addType(companionBuilder.build())

    // column register generation
    val columnRegSpecGenerator = RegisterColumnsGenerator(fileBuilder, tableColumnPropsGenerator.genColValues.map { it.second })
    classBuilder.addProperty(columnRegSpecGenerator.generate())

    // serializer generator
    val serializerGenerator = SerializerGenerator(fileBuilder, pack, className, tableColumnPropsGenerator.genColValues)
    classBuilder.addFunction(serializerGenerator.generate())

    // deserializer generator
    val deserializerGenerator = DeserializerGenerator(fileBuilder, pack, className,
        tableColumnPropsGenerator.genColValues)
    classBuilder.addFunction(deserializerGenerator.generate())

    // migrations
    val elemMap = HashMap<Element, String>()
    columnSpecs.forEach {
      elemMap[it.key.first] = it.key.second
    }
    val migrationGenerator = MigrationGenerator(fileBuilder, elemMap)
    val migrationFunc = migrationGenerator.generate()
    if (migrationFunc != null) classBuilder.addFunction(migrationFunc)

    fileBuilder.addType(classBuilder.build())
    val file = fileBuilder.build()
    val kaptKotlinGeneratedDir = processingEnv.options[KAPT_KOTLIN_GENERATED_OPTION_NAME]!!
    file.writeTo(File(kaptKotlinGeneratedDir))
  }


  override fun getSupportedAnnotationTypes(): MutableSet<String> = mutableSetOf(
      Entity::class.java.name,
      DatabaseEntity::class.java.name
  )

  companion object {
    const val KAPT_KOTLIN_GENERATED_OPTION_NAME = "kapt.kotlin.generated"
  }

}